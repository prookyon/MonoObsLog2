# Technical Documentation for AI Assistants

## Architecture Overview

**Pattern**: MVC-like with centralized database access
- [`MainWindow`](src/mainwindow.cpp) - Main controller, manages tab lifecycle
- [`DatabaseManager`](src/databasemanager.cpp) - Singleton-style database accessor
- Tab classes - Individual controllers for each tab's UI and logic
- `.ui` files - Qt Designer XML for visual layouts

## File Structure

```
include/*.h          - Header files (class declarations)
include/tabs/*.h     - Header files for tab related classes (class declarations)
include/db/*.h       - Header files for database classes (class declarations)
src/*.cpp            - Implementation files
src/tabs/*.cpp       - Implementation files for tab related classes
src/db/*.cpp         - Implementation files for database classes
uifiles/*.ui         - Qt Designer UI files (XML)
build/               - Generated: moc_*, ui_*, compiled objects
```

## Key Conventions

### Naming
- Tab classes: `{Name}Tab` (e.g., [`ObjectsTab`](include/tabs/objectstab.h))
- UI files: `{name}_tab.ui` (lowercase)
- Generated: `ui_{name}_tab.h` (auto-generated by Qt's UIC)

### Qt Patterns
- All QObject-derived classes use `Q_OBJECT` macro for signal/slot support
- UI members accessed via `ui->widgetName`
- Parent-child memory management (parent owns children)
- Use `std::unique_ptr` for owned objects without Qt parent

### Tab Class Structure
```cpp
class TabName : public QWidget {
    Q_OBJECT
public:
    explicit TabName(DatabaseManager* dbManager, QWidget *parent = nullptr);
    ~TabName();
    void initialize();    // Called once after construction
    void refreshData();   // Called to reload from database
private:
    Ui::TabName *ui;           // Generated from .ui file
    DatabaseManager* m_dbManager;  // Non-owning pointer
};
```

## Database Schema

**Creation Order** (due to foreign keys):
1. `filter_types` (no dependencies)
2. `cameras`, `telescopes`, `objects`, `sessions` (independent)
3. `filters` (depends on `filter_types`)
4. `observations` (depends on all above)

**Key Relationships**:
- `filters.filter_type_id` â†’ `filter_types.id`
- `observations` links to: sessions, objects, cameras, telescopes, filters

**Database File**: User-configurable path, set via `database_path` setting

## Implementation Guide

### Adding New Tab Functionality

1. **Edit UI**: Modify `uifiles/{tab}tab.ui` with Qt Designer
2. **Implement Logic**: Add to `src/tabs/{tab}tab.cpp`:
   ```cpp
   void TabName::initialize() {
       // Setup UI state, connect signals
       connect(ui->button, &QPushButton::clicked, this, &TabName::onButtonClick);
       refreshData();
   }
   
   void TabName::refreshData() {
       QSqlQuery query(m_dbManager->database());
       query.exec("SELECT * FROM table");
       // Populate UI with results
   }
   ```

### CRUD Operations Pattern (see [`ObjectsTab`](src/tabs/objectstab.cpp))

**UI Layout**: QTableWidget + Add/Edit/Delete buttons
- Hide ID column, store in Qt::UserRole: `item->setData(Qt::UserRole, id)`
- Retrieve ID: `item->data(Qt::UserRole).toInt()`

**Custom Dialog**: Create helper method for unified Add/Edit form
```cpp
bool showObjectDialog(QString &name, QString &field1, QString &field2) {
   QDialog dialog(this);
   QFormLayout *layout = new QFormLayout(&dialog);
   // Add QLineEdit fields for each property
   // Return true if OK clicked, false if cancelled
}
```

**Operations**:
- **Add**: Show dialog, INSERT with parameterized query, `refreshData()`
- **Edit**: Get selected row ID, pre-fill dialog, UPDATE, `refreshData()`
- **Delete**: Show `QMessageBox::question()` confirmation, DELETE, `refreshData()`
- No success popups (silent operations), show errors only

### Repository Pattern (see [`ObjectsRepository`](src/db/objectsrepository.cpp))

**Purpose**: Separate database queries from UI logic for better maintainability and testability.

**Structure**:
- Data struct for table row representation
- Repository class with CRUD methods
- Returns data structs or error messages via reference parameters

**Example** ([`ObjectsRepository`](include/db/objectsrepository.h)):
```cpp
// Data struct
struct ObjectData {
    int id;
    QString name;
    QVariant ra, dec;  // Can be null
};

// Repository class
class ObjectsRepository : public QObject {
    Q_OBJECT
public:
    explicit ObjectsRepository(DatabaseManager *dbManager, QObject *parent = nullptr);
    QVector<ObjectData> getAllObjects(QString &errorMessage);
    bool addObject(const QString &name, const QVariant &ra, const QVariant &dec, QString &errorMessage);
    bool updateObject(int id, const QString &name, const QVariant &ra, const QVariant &dec, QString &errorMessage);
    bool deleteObject(int id, QString &errorMessage);
};
```

**Usage in Tab** ([`ObjectsTab`](src/tabs/objectstab.cpp)):
```cpp
// Constructor: create repository
m_repository = new ObjectsRepository(m_dbManager, this);

// Query data
QString errorMessage;
QVector<ObjectData> objects = m_repository->getAllObjects(errorMessage);
if (!errorMessage.isEmpty()) {
    QMessageBox::warning(this, "Error", errorMessage);
}

// Insert/Update/Delete
if (!m_repository->addObject(name, ra, dec, errorMessage)) {
    QMessageBox::warning(this, "Error", errorMessage);
}
```

**When to Use**: For tabs with complex queries or when multiple tabs need the same data access.

### Database Operations (Direct Access)

```cpp
// Access database through manager
QSqlDatabase& db = m_dbManager->database();
QSqlQuery query(db);

// Parameterized queries (prevent SQL injection)
query.prepare("INSERT INTO table (col) VALUES (:value)");
query.bindValue(":value", data);
query.exec();

// Error handling
if (!query.exec()) {
    qDebug() << "Error:" << query.lastError().text();
}
```

### Signal/Slot Pattern

```cpp
// In header
signals:
    void dataChanged();
    
private slots:
    void onButtonClicked();

// In implementation
connect(ui->button, &QPushButton::clicked, this, &ClassName::onButtonClicked);
emit dataChanged();  // Notify listeners
```

## Build System

**CMake Configuration**:
- [`CMakeLists.txt`](CMakeLists.txt) - Auto-configured for Qt6
- `CMAKE_AUTOMOC=ON` - Automatic MOC (Meta-Object Compiler)
- `CMAKE_AUTOUIC=ON` - Automatic UIC (UI Compiler)
- `CMAKE_AUTOUIC_SEARCH_PATHS=uifiles` - UI file location

**Build Process**:
1. UIC generates `ui_*.h` from `.ui` files
2. MOC generates `moc_*.cpp` from Q_OBJECT classes
3. Compiler builds all `.cpp` and `moc_*.cpp`
4. Linker creates executable with Qt libraries

## Common Tasks

### Add UI Widget
1. Open `.ui` file in Qt Designer
2. Drag widget, set objectName property
3. Access in code: `ui->objectName`

### Add Database Table
1. Add CREATE TABLE to [`DatabaseManager::createTables()`](src/db/databasemanager.cpp)
2. Maintain foreign key order
3. Consider adding to `.gitignore` for `.db` files

### Add New Tab
1. Create files: `include/{name}tab.h`, `src/{name}tab.cpp`, `uifiles/{name}tab.ui`
2. Add to [`CMakeLists.txt`](CMakeLists.txt) (3 lists: SOURCES, HEADERS, UI)
3. Add to [`MainWindow`](include/mainwindow.h): member + initialization
4. Add tab to [`uifiles/mainwindow.ui`](uifiles/mainwindow.ui:19)

## Important Notes

- **Memory**: Qt parent-child manages most memory; use smart pointers for non-Qt objects
- **Database**: Single QSqlDatabase instance shared via [`DatabaseManager`](include/db/databasemanager.h)
- **Thread Safety**: Current design is single-threaded (UI thread only)
- **UI Files**: Never edit `ui_*.h` directly (regenerated on build)
- **Signals/Slots**: Prefer new syntax: `&Class::method` over `SIGNAL()` macro

## Debugging

```cpp
#include <QDebug>
qDebug() << "Variable:" << value;

// SQL debugging
query.exec();
qDebug() << query.executedQuery();
qDebug() << query.lastError().text();
```

## Utility classes

### SIMBAD Query (Network Operations)

**Pattern**: Asynchronous HTTP requests with signal-based callbacks

**Classes**:
- [`SimbadQuery`](include/simbadquery.h) - Queries SIMBAD astronomical database for coordinates
- Uses Qt's `QNetworkAccessManager` for async HTTP GET requests
- Parses VOTable XML responses

**Usage in [`ObjectsTab`](src/objectstab.cpp)** (Add/Edit dialog):
```cpp
// Create query object (reusable, one per tab)
m_simbadQuery = new SimbadQuery(this);
connect(m_simbadQuery, &SimbadQuery::coordinatesReceived,
        this, &ObjectsTab::onCoordinatesReceived);
connect(m_simbadQuery, &SimbadQuery::errorOccurred,
        this, &ObjectsTab::onSimbadError);

// Query object by name
m_simbadQuery->queryObject("M31");

// Handle results
void onCoordinatesReceived(double ra, double dec, const QString &name) {
    double raHours = ra / 15.0;  // Convert degrees to hours
    m_dialogRaEdit->setText(QString::number(raHours, 'f', 6));
    m_dialogDecEdit->setText(QString::number(dec, 'f', 6));
}
```

**Dialog Safety Pattern** (prevent segfaults with destroyed widgets):
- Use `QPointer<Widget>` in lambdas to safely track dialog widgets
- Store `QMetaObject::Connection` objects and disconnect on dialog destruction
- Check `if (safePtr)` before accessing widget in async callbacks

**Coordinate Format**:
- SIMBAD returns: RA in degrees (0-360), DEC in degrees (-90 to +90)
- Database stores: RA in hours (0-24), DEC in degrees
- Conversion: `raHours = raDegrees / 15.0`

### SettingsManager (Application Settings)

**Pattern**: JSON-based persistent settings storage

**Classes**:
- [`SettingsManager`](include/settingsmanager.h) - Manages application settings in `~/.MonoObsLog/settings.json`
- Automatically creates directory and file with defaults on first run
- Settings: `moon_illumination_warning_percent`, `moon_angular_separation_warning_deg`, `latitude`, `longitude`, `database_path`

**Database Path Setting**:
- `database_path` has no default - user must select location on first run
- Application startup ([`main.cpp`](src/main.cpp)) validates path and prompts with file dialog if missing/invalid
- User can select existing database or create new one
- If cancelled, application exits (database is mandatory)

**Usage in Tabs** (see [`SessionsTab`](src/tabs/sessionstab.cpp)):
```cpp
// Constructor receives SettingsManager
SessionsTab::SessionsTab(DatabaseManager *dbManager, SettingsManager *settingsManager, QWidget *parent)
    : QWidget(parent), m_settingsManager(settingsManager) { }

// Access settings
if (m_settingsManager) {
    int threshold = m_settingsManager->moonIlluminationWarningPercent();
    double lat = m_settingsManager->latitude();
}
```

**Settings Tab Integration** ([`SettingsTab`](src/tabs/settingstab.cpp)):
- UI controls automatically bound to SettingsManager values
- [`loadSettingsToUI()`](src/tabs/settingstab.cpp:28) - Loads settings into spinboxes
- [`onSaveButtonClicked()`](src/tabs/settingstab.cpp:42) - Saves to JSON file with user feedback

**Adding New Settings**:
1. Add getter/setter to [`SettingsManager`](include/settingsmanager.h)
2. Update [`createDefaultSettings()`](src/settingsmanager.cpp:80) with default value (or omit if no default)
3. Update [`loadSettings()`](src/settingsmanager.cpp:145) and [`saveSettings()`](src/settingsmanager.cpp:154)
4. Add UI control to [`settings_tab.ui`](uifiles/settings_tab.ui) if needed
5. Update [`SettingsTab::loadSettingsToUI()`](src/tabs/settingstab.cpp:28) and [`onSaveButtonClicked()`](src/tabs/settingstab.cpp:42)

### DatabaseBackup (Automated Database Backups)

**Pattern**: Automatic backup creation on application startup

**Classes**:
- [`DatabaseBackup`](include/db/databasebackup.h) - Manages database backups in zip format
- Creates backups in `ObsLogBackup` subfolder of database location
- Backup filename: `observations_backup_YYYY-MM-DD.zip`
- Uses libzip library for cross-platform zip creation

**Automatic Backup Logic** ([`main.cpp`](src/main.cpp:81)):
- Runs on startup after database path validation
- Checks latest backup date from filename
- Creates new backup if latest is older than 7 days or no backups exist
- Non-blocking: application continues even if backup fails

**Usage**:
```cpp
DatabaseBackup backupManager;
QString errorMessage;
if (!backupManager.checkAndBackupIfNeeded(dbPath, errorMessage)) {
    // Handle error - warn user but continue
}
```

### NumericTableWidgetItem class (subclassed QTableWidgetItem)

- should be used for all numeric data columns for proper sorting

## Dependencies

- Qt6Core - Core functionality
- Qt6Widgets - GUI components
- Qt6Sql - Database (includes SQLite driver)
- Qt6Network - HTTP requests (SIMBAD integration)
- libzip - Zip archive creation (database backups)
- Standard C++17 - smart pointers, std::make_unique